[{"title":"Leetcode_328周赛","url":"/2023/01/17/力扣328周赛/","content":"   \n### 你好旅行者!欢迎来到cyt的练功房。本篇文章来记录一下力扣的第328场周赛\n\n## 一、数组元素和与数字和的绝对差\n给你一个正整数数组 **nums** 。\n\n- **元素和** 是 **nums** 中的所有元素相加求和。\n- **数字和** 是 **nums** 中每一个元素的每一数位（重复数位需多次求和）相加求和。\n返回 **元素和** 与 **数字和** 的绝对差。\n\n注意：两个整数 **x** 和 **y** 的绝对差定义为 **|x - y|** 。\n\n输入：nums = [1,15,6,3]\n\n输出：9\n\n很简单的一道题，就是总的和加上每个数字的和。\n```c++\nclass Solution {\npublic:\n    int differenceOfSum(vector<int>& nums) {\n        int nums1=0,nums2=0;\n        for(int i=0;i<nums.size();i++){\n            nums1+=nums[i];\n            while(nums[i]){\n                nums2+=nums[i]%10;\n                nums[i]/=10;\n            }\n        }\n        return abs(nums1-nums2);\n    }\n};\n```\n## 二、子矩阵元素加 1\n给你一个正整数 **n** ，表示最初有一个 **n x n** 、下标从 **0** 开始的整数矩阵 **mat** ，矩阵中填满了 **0** 。\n\n另给你一个二维整数数组 **query** 。针对每个查询 **query[i] = [row1i, col1i, row2i, col2i]** ，请你执行下述操作：\n\n找出 **左上角** 为(row1i, col1i) 且 **右下角** 为 (row2i, col2i) 的子矩阵，将子矩阵中的 每个元素 加 1 。也就是给所有满足 **row1i <= x <= row2i 和 col1i <= y <= col2i** 的 **mat[x][y]**加 1 。\n返回执行完所有操作后得到的矩阵 mat 。\n\n![download](/力扣328周赛/第二题图片解释.png)\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>> &queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0));\n        vector<vector<int>> diff(n+1, vector<int>(n+1, 0));\n        for (int k = 0; k < queries.size(); k++) {\n            int x1 = queries[k][0];\n            int y1 = queries[k][1];\n            int x2 = queries[k][2];\n            int y2 = queries[k][3];\n            diff[x1][y1]++;\n            diff[x2+1][y1]--;\n            diff[x2+1][y2+1]++;\n            diff[x1][y2+1]--;\n        }\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                if(i > 0) diff[i][j] += diff[i - 1][j];\n                if(j > 0) diff[i][j] += diff[i][j - 1];\n                if(i > 0 && j > 0) diff[i][j] -= diff[i - 1][j - 1];\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                mat[i][j]=diff[i][j];\n            }\n        }\n        return mat;\n    }\n};\n```\n## 三、统计好子数组的数目\n给你一个整数数组 **nums** 和一个整数 **k** ，请你返回 **nums** 中 好 子数组的数目。\n\n一个子数组 **arr** 如果有 至少 **k** 对下标 **(i, j) 满足 i < j 且 arr[i] == arr[j]** ，那么称它是一个 好 子数组。\n\n子数组 是原数组中一段连续 非空 的元素序列。\n\n子数组是一个连续的过程，思考大致为双指针算法仔细一思考确实是当j确定时，i单调向前进，所以可以用双指针来做。\n\n定义[i,j]用hash表存储[i,j]中每个数出现的次数，**res**为出现的对数，hash[c]每多出现一次，res就增加hash[c]-1;\n首先移动j，当j移动到某一个res>=k时ans++，**（此时不能是ans+=(nums.size()-j)，因为j会继续移动导致重复计算）**，在res>=k时，移动i，i每次向右移动一个判定是否成立，若成立，则ans+=(nums.size()-j)，这个不会重复。\n\n```c++\nclass Solution {\npublic:\n    long long countGood(vector<int>& nums, int k) {\n        long long i=0,j=1,res=0,ans=0;\n        unordered_map<int,long long> hash;\n        hash[nums[0]]++;\n        while(j<nums.size()){\n            hash[nums[j]]++;\n            if(hash[nums[j]]>1)res+=(hash[nums[j]]-1);\n            if(res>=k){\n                ans+=1;\n            }\n            while(i<j){\n                res-=(hash[nums[i]]-1);\n                if(res>=k){\n                    ans+=(nums.size()-j);\n                    hash[nums[i++]]--;\n                }\n                else{\n                    res+=(hash[nums[i]]-1);\n                    break;\n                }\n            }\n            j++;\n        }\n        return ans;\n        \n    }\n};\n```\n## 四、最大价值和与最小价值和的差值\n根本做不出来，感觉应该是树形dp，写出来超时，看了题解也不知道为啥错\n```c++\nclass Solution {\npublic:\n    long ans=0;\n    // dp的含义是从x到fa的最大路径和第二大路径\n    pair<long,long> dp(int x,int fa,vector<vector<int>> tu,vector<int> price){\n        long max_s1=price[x],temp=price[x];\n        long max_s2=0;\n        pair<long,long> p;\n        for(auto y:tu[x]){\n            if(y==fa)continue;\n            auto[s1, s2] = dp(y, x,tu,price);\n            ans=max(ans, max(max_s1 + s2, max_s2 + s1));\n            max_s1=max(max_s1,s1+temp);\n            max_s2=max(max_s2,s2+temp);\n        }\n        return {max_s1,max_s2};\n    }\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\n        vector<vector<int>> tu(n);\n        for(auto x:edges){\n            tu[x[0]].push_back(x[1]);\n            tu[x[1]].push_back(x[0]);\n        }\n        dp(0,0,tu,price);\n        return ans;\n    }\n};\n```","tags":["算法"],"categories":["周赛"]},{"title":"KMP算法","url":"/2023/01/13/kmp算法/","content":"   \n### 你好旅行者!欢迎来到cyt的练功房。本篇文章来记录一个我刚学会的算法KMP算法，主要用于字符匹配\n\n先在开头约定，本文用 **pat** 表示模式串，长度为 **M**，**txt** 表示文本串，长度为 **N**。KMP 算法是在 **txt** 中查找子串 **pat**，如果存在，返回这个子串的起始索引，否则返回 -1。\n\n# 一、传统字符匹配\n众所周知，传统的字符串匹配是一个O(N*M)的算法，在大多数的场合是过不了题的。大致如下\n```c++\nint search(string pat,string txt){\n    # pat长度为M txt长度为N\n    for(int i=0;i<=N-M;i++){\n        int j;\n        for(j=0;j<M;j++){\n            if(!pat[j]==txt[i+j])break;\n        }\n        if(j==M)return true;\n    }\n    return false;\n}\n```\n对于暴力算法，如果出现不匹配字符，同时回退 txt 和 pat 的指针，嵌套 for 循环，时间复杂度 O(MN)，空间复杂度O(1)。最主要的问题是，如果字符串中重复的字符比较多，该算法就显得很蠢。\n\nKMP 算法的不同之处在于，它会花费空间来记录一些信息，只需要遍历一遍  ","tags":["算法"],"categories":["动态规划"]},{"title":"树莓派使用教程2","url":"/2022/11/23/树莓派使用教程2/","content":"![download](/树莓派使用教程2/disk.png)          "},{"title":"树莓派新手使用教程1","url":"/2022/11/14/树莓派简明教程1/","content":"### 你好旅行者!欢迎来到cyt的练功房。本教程是关于树莓派的简单配置与安装，适用于新手，会装系统的直接跳至后方即可。\n# 一、树莓派是什么\n基于arm的卡片式电脑主板，其系统基于linux\n# 二、树莓派可以做什么\n2.1 奇奇怪怪的机器人  \n很多比赛，个人项目都可以看到，部分项目可搭配或单独使用单片机实现  \n2.2 进去奇怪的数据库  \n口袋里装着树莓派，装上kali系统和一体式的小型屏幕和键盘，带着特意改小的黄色网线插在学校教学楼某个角落里的插口里然后进去奇怪的数据库。  \n总结：很不错的刑法，只有中午能用  \n2.3 挖矿  \n不建议用个人常用的设备，似乎大部分尝试过的pi主只勉强回了电费和设备的本，不建议挖  \n2.4 私人服务器  \n创建一个私人的服务器，搭配内网映射可以从外网访问，经过改造你还可以拥有一个路由器和一个游戏服务器（老版mc和cs玩家狂喜），你甚至可以制作监控以及一个广告网站。\n# 三、入门所需要的准备\n## 3.1 硬件准备：\n显示器（可根据个人选择使用）   \n    \t一台电脑（可根据个人选择安装putty或者vncviewer，或者不安装）  \n        一部手机（安装vncviewer或者juicessh）  \n        树莓派用屏幕（尺寸包括5寸以上，常见为7寸至15.6寸不等，建议无额外需求选择5寸或7寸作为维修使用的屏幕即可。备注：树莓派4b及4b+采用的是micro hdmi接口，应当准备对应的转接头搭配使用，价格低廉。）  \n        设备：建议使用树莓派4b，4b+，根据个人需求选择内存（建议4g或者8g）  \n        读卡器一个  \n        sd卡一张（推荐金士顿16g版本，可根据个人需求选择大小，建议选择质量好的sd卡避免数据损坏或无法读写造成损失）  \n        树莓派散热片（粘贴在树莓派cpu上散热，但要小心在摘除时不要破坏芯片）  \n        键鼠一套（可选择无线版本，但建议某多多购买有线版本即可）  \n        安卓充电线及插头（至少两条，树莓派购买套件会赠送一条树莓派专用版本，建议将其作为机器电源线，另一条给屏幕单独供电）  \n        其他：无线wifi一个（便于携带使用，如果使用wifi，当连接设备出现变化时ip地址可能改变，（如果使用手机流量不方便进行小程序端调试，建议单独供电，避免树莓派因电压过低无法显示）  \n        闲置的小风扇或手游散热器（帮助树莓派散热，物美价廉）\n## 3.2 安装教程\n1.下载树莓派官方系统（带桌面版）https://www.raspberrypi.com/software/operating-systems/，  \n点击最新版下载\n![download](/树莓派简明教程1/download.png) \n        2.下载SD formatter 和Win32Diskimager(\n        sd的地址：\n            https://www.sdcard.org/downloads/formatter/sd-memory-card-formatter-for-windows-download/\n        Diskimager的地址：\n            https://win32diskimager.download/download-win32-disk-imager/\n        )\n        3.将sd卡插入读卡器并将读卡器插入电脑，打开SD的exe文件初始化(切忌点windows弹出来的某些弹窗，按了一次就要重做)\n![download](/树莓派简明教程1/SD_formatter.png)     \n        4.打开disk选中镜像文件，点击写入即可\n![download](/树莓派简明教程1/disk.png)        \n\n## 3.3 使用\n此时就需要我之前提到的小屏幕啦！  \n将micro hdmi一头插入树莓派的micro接口有一模一样的两个另一面插入电脑屏幕的hdmi接口\n最简单的配置，上电后自动进入桌面，自动弹出配置向导，一步步跟着走就行，和配置Windows一样。\n初次进入会有个欢迎界面，选择 next 进入初始化配置\n第一步：选择国家，选中国就好了，**将下方“Use US Keyboard”选上，建议同时选上使用英语。**\n第二步：修改树莓派的密码，默认密码是 raspberry，这步根据个人口味来写。\n第三步：Set up Screen，直接next就好\n第四步：连接wifi，有就连，没有就跳过，问题不大。**建议此时连上自己的热点方便使用ip**\n第五步：update，跳过就好，服务器连不上，连上也很慢，有梯子请便。建议跳过\n第六步：重启\n经过此步就成功进入屏幕啦！！！恭喜恭喜！！！\n鼠标移到右上角的网络那里就可以看到自己的IP啦 **这非常重要，可以拿小本本记一下**\n此版本应该有自带的vncviewer，输入ctrl+shift+T打开命令行，先输入**输入ctrl+shift+T打开命令行 输入vncserver打开vncviewer**再输入**sudo raspi-config** \n![config](/树莓派简明教程1/config.png)\n进入3 Interface options\n![config](/树莓派简明教程1/vnc.png)\n全部回车打开即可\n## 3.4 使用电脑连接树莓派\n电脑上下载vncviewer与putty：\nhttps://www.realvnc.com/en/connect/download/viewer/\nhttps://putty.org/\n以后再也不需要那块屏幕了，可以扔在一边了\n打开下好的putty\n![config](/树莓派简明教程1/putty.png)\n在hostname处输入刚在小本本中记录的ip地址即可在电脑上打开树莓派的命令行\n打开vncviewer 按下ctrl+n \n![config](/树莓派简明教程1/vncviewer.png)\n输入刚才的ip地址（名字看你自己） 双击新建的连接就可以成功连上树莓派了\n\n","tags":["rasberry_pi"],"categories":["xinshou"]}]