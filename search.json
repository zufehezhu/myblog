[{"title":"力扣每日一题3.18（字符串匹配）","url":"/2023/03/18/C++模板/","content":"### 你好旅行者!欢迎来到cyt的练功房。本篇文章来记录一下力扣的2023.3.18的每日一题，这个好像传统的字符串匹配$O_{n^2}$ 做不出来，就学了一下$O_{n}$ 记录一下 。\n\n# 1616. 分割两个字符串得到回文串\n给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。由 a 可以得到两个字符串： $a_{prefix}$ 和 $a_{suffix}$ ，满足 a = $a_{prefix}$ + $a_{suffix}$ ，同理，由 b 可以得到两个字符串 $b_{prefix}$ 和 $b_{suffix}$ ，满足 b = $b_{prefix}$ + $b_{suffix}$ 。请你判断 $a_{prefix}$ + $b_{suffix}$ 或者 $b_{prefix}$ + $a_{suffix}$ 能否构成回文串。\n\n当你将一个字符串 s 分割成 $s_{prefix}$ 和 $s_{suffix}$$s_{suffix}$ 或者 $s_{prefix}$ 可以为空。比方说， s = \"abc\" 那么 \"\" + \"abc\" ， \"a\" + \"bc\" ， \"ab\" + \"c\" 和 \"abc\" + \"\" 都是合法分割。\n\n如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。\n\n注意， x + y 表示连接字符串 x 和 y 。\n\n输入：a = \"abdef\", b = \"fecab\"\n输出：true\n\n## 容易想到的思路是取每一个分割时的字符串，将两个字符串记录下来，判断是否是回文序列，看了一眼范围10^5，应该是过不了的，但是还是试了一下\n~~~ c++\nclass Solution {\npublic:\n    bool check(string &s){\n        int begin=s.size()/2;\n        int left,right;\n        // 如果字符串的长度是奇数\n        if(s.size()%2){\n            left=begin-1;right=begin+1;\n            while(left>=0&&right<=s.size()-1){\n                if(left<0||right>s.size()-1)break;\n                if(s[left]!=s[right]){\n                    return false;\n                }\n                left--;\n                right++;\n            }\n        }else{\n            // 如果字符串的长度是偶数\n            // cout<<11111111<<endl;\n            left=begin-1;right=begin;\n            while(left>=0&&right<=s.size()-1){\n                if(left<0||right>s.size()-1)break;\n                if(s[left]!=s[right]){\n                    return false;\n                }\n                left--;\n                right++;\n            }\n        }\n        return true;\n    }\n    bool checkPalindromeFormation(string &a, string &b) {\n        int n=a.size();\n        string res1,res2;\n        if(check(a)||check(b)){\n            return true;\n        }\n        for(int i=0;i<a.size();i++){\n            // 遍历所有可以形成的字符串\n            res1=\"\",res2=\"\";\n            res1=res1+a.substr(0,i)+b.substr(i,n-i);\n            res2=res2+b.substr(0,i)+a.substr(i,n-i);\n            if(check(res1)||check(res2)){\n                return true;\n            }\n        }\n        return false;\n\n    }\n};\n~~~\n跑了一下，果然超时了 QAQ只能在想点别的办法了。\n想想$O_{n}$的做法呃，先匹配两个字符串的最长前后缀，如果没有前后缀的话怎么也不可能成为回文的序列，再看剩下的中间部分有没有回文序列，如果有就找到了，没有就没有。\n~~~c++\nclass Solution {\npublic:\n    bool check(string &s){\n        int begin=s.size()/2;\n        int left,right;\n        // 如果字符串的长度是奇数\n        if(s.size()%2){\n            left=begin-1;right=begin+1;\n            while(left>=0&&right<=s.size()-1){\n                if(left<0||right>s.size()-1)break;\n                if(s[left]!=s[right]){\n                    return false;\n                }\n                left--;\n                right++;\n            }\n        }else{\n            // 如果字符串的长度是偶数\n            // cout<<11111111<<endl;\n            left=begin-1;right=begin;\n            while(left>=0&&right<=s.size()-1){\n                if(left<0||right>s.size()-1)break;\n                if(s[left]!=s[right]){\n                    return false;\n                }\n                left--;\n                right++;\n            }\n        }\n        return true;\n    }\n    bool checkPalindromeFormation(string &a, string &b) {\n        int n=a.size();\n        string res1,res2;\n        int begin=0,end=b.size()-1;\n        // 匹配最长前缀后缀\n        while(a[begin]==b[end]&&begin<end){\n            begin++;end--;\n        }\n        int begin1=0,end1=b.size()-1;\n        while(b[begin1]==a[end1]&&begin1<end1){\n            begin1++;end1--;\n        }\n        if(begin1>begin){\n            begin=begin1;\n            end=end1;\n        }\n        if(begin>=end)return true;\n        res1=a.substr(begin,end-begin+1),res2=b.substr(begin,end-begin+1);\n        return check(res1)||check(res2);\n\n\n    }\n};\n~~~\n需要注意的是要whlie两侧，一侧是a开始，一侧是b开始。\n## 嗯~ o(*￣▽￣*)o 今天的每日一题完成了！！！又学到了很多","tags":["算法"],"categories":["回文串"]},{"title":"力扣每日一题3.18（字符串匹配）","url":"/2023/03/18/每日一题（字符串匹配）/","content":"### 你好旅行者!欢迎来到cyt的练功房。本篇文章来记录一下力扣的2023.3.18的每日一题，这个好像传统的字符串匹配$O_{n^2}$ 做不出来，就学了一下$O_{n}$ 记录一下 。\n\n# 1616. 分割两个字符串得到回文串\n给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。由 a 可以得到两个字符串： $a_{prefix}$ 和 $a_{suffix}$ ，满足 a = $a_{prefix}$ + $a_{suffix}$ ，同理，由 b 可以得到两个字符串 $b_{prefix}$ 和 $b_{suffix}$ ，满足 b = $b_{prefix}$ + $b_{suffix}$ 。请你判断 $a_{prefix}$ + $b_{suffix}$ 或者 $b_{prefix}$ + $a_{suffix}$ 能否构成回文串。\n\n当你将一个字符串 s 分割成 $s_{prefix}$ 和 $s_{suffix}$$s_{suffix}$ 或者 $s_{prefix}$ 可以为空。比方说， s = \"abc\" 那么 \"\" + \"abc\" ， \"a\" + \"bc\" ， \"ab\" + \"c\" 和 \"abc\" + \"\" 都是合法分割。\n\n如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。\n\n注意， x + y 表示连接字符串 x 和 y 。\n\n输入：a = \"abdef\", b = \"fecab\"\n输出：true\n\n## 容易想到的思路是取每一个分割时的字符串，将两个字符串记录下来，判断是否是回文序列，看了一眼范围10^5，应该是过不了的，但是还是试了一下\n~~~ c++\nclass Solution {\npublic:\n    bool check(string &s){\n        int begin=s.size()/2;\n        int left,right;\n        // 如果字符串的长度是奇数\n        if(s.size()%2){\n            left=begin-1;right=begin+1;\n            while(left>=0&&right<=s.size()-1){\n                if(left<0||right>s.size()-1)break;\n                if(s[left]!=s[right]){\n                    return false;\n                }\n                left--;\n                right++;\n            }\n        }else{\n            // 如果字符串的长度是偶数\n            // cout<<11111111<<endl;\n            left=begin-1;right=begin;\n            while(left>=0&&right<=s.size()-1){\n                if(left<0||right>s.size()-1)break;\n                if(s[left]!=s[right]){\n                    return false;\n                }\n                left--;\n                right++;\n            }\n        }\n        return true;\n    }\n    bool checkPalindromeFormation(string &a, string &b) {\n        int n=a.size();\n        string res1,res2;\n        if(check(a)||check(b)){\n            return true;\n        }\n        for(int i=0;i<a.size();i++){\n            // 遍历所有可以形成的字符串\n            res1=\"\",res2=\"\";\n            res1=res1+a.substr(0,i)+b.substr(i,n-i);\n            res2=res2+b.substr(0,i)+a.substr(i,n-i);\n            if(check(res1)||check(res2)){\n                return true;\n            }\n        }\n        return false;\n\n    }\n};\n~~~\n跑了一下，果然超时了 QAQ只能在想点别的办法了。\n想想$O_{n}$的做法呃，先匹配两个字符串的最长前后缀，如果没有前后缀的话怎么也不可能成为回文的序列，再看剩下的中间部分有没有回文序列，如果有就找到了，没有就没有。\n~~~c++\nclass Solution {\npublic:\n    bool check(string &s){\n        int begin=s.size()/2;\n        int left,right;\n        // 如果字符串的长度是奇数\n        if(s.size()%2){\n            left=begin-1;right=begin+1;\n            while(left>=0&&right<=s.size()-1){\n                if(left<0||right>s.size()-1)break;\n                if(s[left]!=s[right]){\n                    return false;\n                }\n                left--;\n                right++;\n            }\n        }else{\n            // 如果字符串的长度是偶数\n            // cout<<11111111<<endl;\n            left=begin-1;right=begin;\n            while(left>=0&&right<=s.size()-1){\n                if(left<0||right>s.size()-1)break;\n                if(s[left]!=s[right]){\n                    return false;\n                }\n                left--;\n                right++;\n            }\n        }\n        return true;\n    }\n    bool checkPalindromeFormation(string &a, string &b) {\n        int n=a.size();\n        string res1,res2;\n        int begin=0,end=b.size()-1;\n        // 匹配最长前缀后缀\n        while(a[begin]==b[end]&&begin<end){\n            begin++;end--;\n        }\n        int begin1=0,end1=b.size()-1;\n        while(b[begin1]==a[end1]&&begin1<end1){\n            begin1++;end1--;\n        }\n        if(begin1>begin){\n            begin=begin1;\n            end=end1;\n        }\n        if(begin>=end)return true;\n        res1=a.substr(begin,end-begin+1),res2=b.substr(begin,end-begin+1);\n        return check(res1)||check(res2);\n\n\n    }\n};\n~~~\n需要注意的是要whlie两侧，一侧是a开始，一侧是b开始。\n## 嗯~ o(*￣▽￣*)o 今天的每日一题完成了！！！又学到了很多","tags":["算法"],"categories":["回文串"]},{"title":"Leetcode_335周赛","url":"/2023/03/05/力扣335周赛/","content":"   \n### 你好旅行者!欢迎来到cyt的练功房。本篇文章来记录一下力扣的第335场周赛，好久没打周赛了菜的一一一一一，就做出了两题，知道思路但就是写不出来嘤嘤嘤。\n# 一、递枕头\nn 个人站成一排，按从 1 到 n 编号。\n\n最初，排在队首的第一个人拿着一个枕头。每秒钟，拿着枕头的人会将枕头传递给队伍中的下一个人。一旦枕头到达队首或队尾，传递方向就会改变，队伍会继续沿相反方向传递枕头。\n\n例如，当枕头到达第 n 个人时，TA 会将枕头传递给第 n - 1 个人，然后传递给第 n - 2 个人，依此类推。\n给你两个正整数 n 和 time ，返回 time 秒后拿着枕头的人的编号\n\n输入：n = 4, time = 5\n\n输出：2\n\n## 解法：\n找个规律就行，有规律长度是2*n-2，先取余就行。\n```c++\nclass Solution {\npublic:\n    int passThePillow(int n, int time) {\n        time--;\n        time %= (2*n-2);\n\n        if(time + 2<=n)return time+2;\n        else return n - (time-n +2);\n    }\n};\n```\n# 二、二叉树中的第 K 大层和\n给你一棵二叉树的根节点 **root** 和一个正整数 k 。\n\n树中的 层和 是指 同一层 上节点值的总和。\n\n返回树中第 k 大的层和（不一定不同）。如果树少于 k 层，则返回 -1 。\n\n注意，如果两个节点与根节点的距离相同，则认为它们在同一层。\n## 解法：\n标准的bfs题目，wa四次，写出了经典的忘记循环size，标准的0分\n\n输入：root = [5,8,9,2,1,3,7,4,6], k = 2\n\n输出：13\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*> q;\n        q.push(root);\n        vector<long long> res;\n        while(!q.empty()){\n            int si=q.size();\n            long long sum=0;\n            for(int i=0;i<si;i++){\n                TreeNode *top=q.front();\n                q.pop();\n                if(top->left!=nullptr)q.push(top->left);\n                if(top->right!=nullptr)q.push(top->right);\n                sum+=top->val;\n            }\n            res.push_back(sum);\n        }\n        if(res.size()<k)return -1;\n        sort(res.begin(),res.end(),greater<long long>());\n        return res[k-1];\n        \n        \n    }\n};\n```\n# 三、分割数组使乘积互质\n给你一个长度为 n 的整数数组 nums ，下标从 0 开始。\n\n如果在下标 i 处 分割 数组，其中 0 <= i <= n - 2 ，使前 i + 1 个元素的乘积和剩余元素的乘积互质，则认为该分割 有效 。\n\n例如，如果 nums = [2, 3, 3] ，那么在下标 i = 0 处的分割有效，因为 2 和 9 互质，而在下标 i = 1 处的分割无效，因为 6 和 3 不互质。在下标 i = 2 处的分割也无效，因为 i == n - 1 。\n返回可以有效分割数组的最小下标 i ，如果不存在有效分割，则返回 -1 。\n\n当且仅当 gcd(val1, val2) == 1 成立时，val1 和 val2 这两个值才是互质的，其中 gcd(val1, val2) 表示 val1 和 val2 的最大公约数。\n\n输入：nums = [4,7,8,15,3,5]\n\n输出：2\n\n## 解法：\n这凭什么超时，这不是铁n方，差最后一个实例死活过不了逆天。\n~~~c++\nclass Solution {\npublic:\n    int findValidSplit(vector<int>& nums) {\n        int right=0;\n        int left=0;\n        for(int i=left+1;i<nums.size();i++){\n            if(gcd(nums[left],nums[i])!=1){\n                    right=max(right,i);\n            }\n        }\n        while(right<nums.size()&&left<right){\n            for(int i=right+1;i<nums.size();i++){\n                if(gcd(nums[left],nums[i])!=1){\n                    right=i;\n                }\n            }\n            if(right==nums.size()-1)return -1;\n            left++;\n        }\n    if(right==nums.size()-1)return -1;\n    return right;\n    }\n};\n~~~\n# 四、获得分数的方法数\n考试中有 n 种类型的题目。给你一个整数 target 和一个下标从 0 开始的二维整数数组 types ，其中 types[i] = [$count_i$, $marks_i$] 表示第 i 种类型的题目有 $count_i$ 道，每道题目对应 $marks_i$ 分。\n\n返回你在考试中恰好得到 target 分的方法数。由于答案可能很大，结果需要对 10^9 +7 取余。\n\n注意，同类型题目无法区分。\n\n比如说，如果有 3 道同类型题目，那么解答第 1 和第 2 道题目与解答第 1 和第 3 道题目或者第 2 和第 3 道题目是相同的。\n\n输入：target = 6, types = [[6,1],[3,2],[2,3]]\n\n输出：7\n## 解法：\n完全不会，背包问题直接忘干净，我是废物。\n~~~c++\n\n~~~","tags":["算法"],"categories":["周赛"]},{"title":"Leetcode_328周赛","url":"/2023/01/17/力扣328周赛/","content":"   \n### 你好旅行者!欢迎来到cyt的练功房。本篇文章来记录一下力扣的第328场周赛\n\n# 一、数组元素和与数字和的绝对差\n## 题目：\n给你一个正整数数组 **nums** 。\n\n- **元素和** 是 **nums** 中的所有元素相加求和。\n- **数字和** 是 **nums** 中每一个元素的每一数位（重复数位需多次求和）相加求和。\n返回 **元素和** 与 **数字和** 的绝对差。\n\n注意：两个整数 **x** 和 **y** 的绝对差定义为 **|x - y|** 。\n\n输入：nums = [1,15,6,3]\n\n输出：9\n\n## 解法：\n很简单的一道题，就是总的和加上每个数字的和。\n```c++\nclass Solution {\npublic:\n    int differenceOfSum(vector<int>& nums) {\n        int nums1=0,nums2=0;\n        for(int i=0;i<nums.size();i++){\n            nums1+=nums[i];\n            while(nums[i]){\n                nums2+=nums[i]%10;\n                nums[i]/=10;\n            }\n        }\n        return abs(nums1-nums2);\n    }\n};\n```\n# 二、子矩阵元素加 1\n## 题目：\n给你一个正整数 **n** ，表示最初有一个 **n x n** 、下标从 **0** 开始的整数矩阵 **mat** ，矩阵中填满了 **0** 。\n\n另给你一个二维整数数组 **query** 。针对每个查询 **query[i] = [row1i, col1i, row2i, col2i]** ，请你执行下述操作：\n\n找出 **左上角** 为(row1i, col1i) 且 **右下角** 为 (row2i, col2i) 的子矩阵，将子矩阵中的 每个元素 加 1 。也就是给所有满足 **row1i <= x <= row2i 和 col1i <= y <= col2i** 的 **mat[x][y]**加 1 。\n返回执行完所有操作后得到的矩阵 mat 。\n\n![download](/力扣328周赛/第二题图片解释.png)\n\n## 解法：\n二维差分模板题，建议直接使用模板进行差分的构建，构建完之后求个前缀和就行了，唯一要注意的是在构建差分数组时数组要多开一个，wa了一次\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>> &queries) {\n        vector<vector<int>> mat(n, vector<int>(n, 0));\n        vector<vector<int>> diff(n+1, vector<int>(n+1, 0));\n        for (int k = 0; k < queries.size(); k++) {\n            int x1 = queries[k][0];\n            int y1 = queries[k][1];\n            int x2 = queries[k][2];\n            int y2 = queries[k][3];\n            diff[x1][y1]++;\n            diff[x2+1][y1]--;\n            diff[x2+1][y2+1]++;\n            diff[x1][y2+1]--;\n        }\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                if(i > 0) diff[i][j] += diff[i - 1][j];\n                if(j > 0) diff[i][j] += diff[i][j - 1];\n                if(i > 0 && j > 0) diff[i][j] -= diff[i - 1][j - 1];\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                mat[i][j]=diff[i][j];\n            }\n        }\n        return mat;\n    }\n};\n```\n# 三、统计好子数组的数目\n## 题目：\n给你一个整数数组 **nums** 和一个整数 **k** ，请你返回 **nums** 中 好 子数组的数目。\n\n一个子数组 **arr** 如果有 至少 **k** 对下标 **(i, j) 满足 i < j 且 arr[i] == arr[j]** ，那么称它是一个 好 子数组。\n\n子数组 是原数组中一段连续 非空 的元素序列。\n## 解法：\n子数组是一个连续的过程，思考大致为双指针算法仔细一思考确实是当j确定时，i单调向前进，所以可以用双指针来做。\n\n定义[i,j]用hash表存储[i,j]中每个数出现的次数，**res**为出现的对数，hash[c]每多出现一次，res就增加hash[c]-1;\n首先移动j，当j移动到某一个res>=k时ans++，**（此时不能是ans+=(nums.size()-j)，因为j会继续移动导致重复计算）**，在res>=k时，移动i，i每次向右移动一个判定是否成立，若成立，则ans+=(nums.size()-j)，这个不会重复。\n\n```c++\nclass Solution {\npublic:\n    long long countGood(vector<int>& nums, int k) {\n        long long i=0,j=1,res=0,ans=0;\n        unordered_map<int,long long> hash;\n        hash[nums[0]]++;\n        while(j<nums.size()){\n            hash[nums[j]]++;\n            if(hash[nums[j]]>1)res+=(hash[nums[j]]-1);\n            if(res>=k){\n                ans+=1;\n            }\n            while(i<j){\n                res-=(hash[nums[i]]-1);\n                if(res>=k){\n                    ans+=(nums.size()-j);\n                    hash[nums[i++]]--;\n                }\n                else{\n                    res+=(hash[nums[i]]-1);\n                    break;\n                }\n            }\n            j++;\n        }\n        return ans;\n        \n    }\n};\n```\n## 四、最大价值和与最小价值和的差值\n根本做不出来，感觉应该是树形dp，写出来超时，看了题解也不知道为啥错\n```c++\nclass Solution {\npublic:\n    long ans=0;\n    // dp的含义是从x到fa的最大路径和第二大路径\n    pair<long,long> dp(int x,int fa,vector<vector<int>> tu,vector<int> price){\n        long max_s1=price[x],temp=price[x];\n        long max_s2=0;\n        pair<long,long> p;\n        for(auto y:tu[x]){\n            if(y==fa)continue;\n            auto[s1, s2] = dp(y, x,tu,price);\n            ans=max(ans, max(max_s1 + s2, max_s2 + s1));\n            max_s1=max(max_s1,s1+temp);\n            max_s2=max(max_s2,s2+temp);\n        }\n        return {max_s1,max_s2};\n    }\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\n        vector<vector<int>> tu(n);\n        for(auto x:edges){\n            tu[x[0]].push_back(x[1]);\n            tu[x[1]].push_back(x[0]);\n        }\n        dp(0,0,tu,price);\n        return ans;\n    }\n};\n```","tags":["算法"],"categories":["周赛"]},{"title":"KMP算法","url":"/2023/01/13/kmp算法/","content":"   \n### 你好旅行者!欢迎来到cyt的练功房。本篇文章来记录一个我刚学会的算法KMP算法，主要用于字符匹配\n\n先在开头约定，本文用 **pat** 表示模式串，长度为 **M**，**txt** 表示文本串，长度为 **N**。KMP 算法是在 **txt** 中查找子串 **pat**，如果存在，返回这个子串的起始索引，否则返回 -1。\n\n# 一、传统字符匹配\n众所周知，传统的字符串匹配是一个O(N*M)的算法，在大多数的场合是过不了题的。大致如下\n```c++\nint search(string pat,string txt){\n    # pat长度为M txt长度为N\n    for(int i=0;i<=N-M;i++){\n        int j;\n        for(j=0;j<M;j++){\n            if(!pat[j]==txt[i+j])break;\n        }\n        if(j==M)return true;\n    }\n    return false;\n}\n```\n对于暴力算法，如果出现不匹配字符，同时回退 txt 和 pat 的指针，嵌套 for 循环，时间复杂度 O(MN)，空间复杂度O(1)。最主要的问题是，如果字符串中重复的字符比较多，该算法就显得很蠢。\n\nKMP 算法的不同之处在于，它会花费空间来记录一些信息，只需要遍历一遍  ","tags":["算法"],"categories":["动态规划"]},{"title":"树莓派使用教程2","url":"/2022/11/23/树莓派使用教程2/","content":"![download](/树莓派使用教程2/disk.png)          "},{"title":"树莓派新手使用教程","url":"/2022/11/14/树莓派新手使用教程/","content":"你好旅行者!","tags":["rasberry_pi"],"categories":["caiji"]},{"title":"树莓派新手使用教程1","url":"/2022/11/14/树莓派简明教程1/","content":"### 你好旅行者!欢迎来到cyt的练功房。本教程是关于树莓派的简单配置与安装，适用于新手，会装系统的直接跳至后方即可。\n# 一、树莓派是什么\n基于arm的卡片式电脑主板，其系统基于linux\n# 二、树莓派可以做什么\n2.1 奇奇怪怪的机器人  \n很多比赛，个人项目都可以看到，部分项目可搭配或单独使用单片机实现  \n2.2 进去奇怪的数据库  \n口袋里装着树莓派，装上kali系统和一体式的小型屏幕和键盘，带着特意改小的黄色网线插在学校教学楼某个角落里的插口里然后进去奇怪的数据库。  \n总结：很不错的刑法，只有中午能用  \n2.3 挖矿  \n不建议用个人常用的设备，似乎大部分尝试过的pi主只勉强回了电费和设备的本，不建议挖  \n2.4 私人服务器  \n创建一个私人的服务器，搭配内网映射可以从外网访问，经过改造你还可以拥有一个路由器和一个游戏服务器（老版mc和cs玩家狂喜），你甚至可以制作监控以及一个广告网站。\n# 三、入门所需要的准备\n## 3.1 硬件准备：\n显示器（可根据个人选择使用）   \n    \t一台电脑（可根据个人选择安装putty或者vncviewer，或者不安装）  \n        一部手机（安装vncviewer或者juicessh）  \n        树莓派用屏幕（尺寸包括5寸以上，常见为7寸至15.6寸不等，建议无额外需求选择5寸或7寸作为维修使用的屏幕即可。备注：树莓派4b及4b+采用的是micro hdmi接口，应当准备对应的转接头搭配使用，价格低廉。）  \n        设备：建议使用树莓派4b，4b+，根据个人需求选择内存（建议4g或者8g）  \n        读卡器一个  \n        sd卡一张（推荐金士顿16g版本，可根据个人需求选择大小，建议选择质量好的sd卡避免数据损坏或无法读写造成损失）  \n        树莓派散热片（粘贴在树莓派cpu上散热，但要小心在摘除时不要破坏芯片）  \n        键鼠一套（可选择无线版本，但建议某多多购买有线版本即可）  \n        安卓充电线及插头（至少两条，树莓派购买套件会赠送一条树莓派专用版本，建议将其作为机器电源线，另一条给屏幕单独供电）  \n        其他：无线wifi一个（便于携带使用，如果使用wifi，当连接设备出现变化时ip地址可能改变，（如果使用手机流量不方便进行小程序端调试，建议单独供电，避免树莓派因电压过低无法显示）  \n        闲置的小风扇或手游散热器（帮助树莓派散热，物美价廉）\n## 3.2 安装教程\n1.下载树莓派官方系统（带桌面版）https://www.raspberrypi.com/software/operating-systems/，  \n点击最新版下载\n![download](/树莓派简明教程1/download.png) \n        2.下载SD formatter 和Win32Diskimager(\n        sd的地址：\n            https://www.sdcard.org/downloads/formatter/sd-memory-card-formatter-for-windows-download/\n        Diskimager的地址：\n            https://win32diskimager.download/download-win32-disk-imager/\n        )\n        3.将sd卡插入读卡器并将读卡器插入电脑，打开SD的exe文件初始化(切忌点windows弹出来的某些弹窗，按了一次就要重做)\n![download](/树莓派简明教程1/SD_formatter.png)     \n        4.打开disk选中镜像文件，点击写入即可\n![download](/树莓派简明教程1/disk.png)        \n\n## 3.3 使用\n此时就需要我之前提到的小屏幕啦！  \n将micro hdmi一头插入树莓派的micro接口有一模一样的两个另一面插入电脑屏幕的hdmi接口\n最简单的配置，上电后自动进入桌面，自动弹出配置向导，一步步跟着走就行，和配置Windows一样。\n初次进入会有个欢迎界面，选择 next 进入初始化配置\n第一步：选择国家，选中国就好了，**将下方“Use US Keyboard”选上，建议同时选上使用英语。**\n第二步：修改树莓派的密码，默认密码是 raspberry，这步根据个人口味来写。\n第三步：Set up Screen，直接next就好\n第四步：连接wifi，有就连，没有就跳过，问题不大。**建议此时连上自己的热点方便使用ip**\n第五步：update，跳过就好，服务器连不上，连上也很慢，有梯子请便。建议跳过\n第六步：重启\n经过此步就成功进入屏幕啦！！！恭喜恭喜！！！\n鼠标移到右上角的网络那里就可以看到自己的IP啦 **这非常重要，可以拿小本本记一下**\n此版本应该有自带的vncviewer，输入ctrl+shift+T打开命令行，先输入**输入ctrl+shift+T打开命令行 输入vncserver打开vncviewer**再输入**sudo raspi-config** \n![config](/树莓派简明教程1/config.png)\n进入3 Interface options\n![config](/树莓派简明教程1/vnc.png)\n全部回车打开即可\n## 3.4 使用电脑连接树莓派\n电脑上下载vncviewer与putty：\nhttps://www.realvnc.com/en/connect/download/viewer/\nhttps://putty.org/\n以后再也不需要那块屏幕了，可以扔在一边了\n打开下好的putty\n![config](/树莓派简明教程1/putty.png)\n在hostname处输入刚在小本本中记录的ip地址即可在电脑上打开树莓派的命令行\n打开vncviewer 按下ctrl+n \n![config](/树莓派简明教程1/vncviewer.png)\n输入刚才的ip地址（名字看你自己） 双击新建的连接就可以成功连上树莓派了\n\n","tags":["rasberry_pi"],"categories":["xinshou"]}]